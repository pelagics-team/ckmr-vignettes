[
  {
    "objectID": "tutorials/about.html",
    "href": "tutorials/about.html",
    "title": "CKMR",
    "section": "",
    "text": "Welcome to the Hobart CKMR workshop 2022\n This website contains vignettes designed to accompany the exercises presented in the workshop. All exercise files can be found on the home folder of the workshop repository.\n\nA few pointers:\nStart at the Tips page if you want an overview of some of the common object classes you are likely to encounter in the exercise code (as well as error messages to look out for when libraries haven’t been loaded properly).\n\nNot all code is shown for clarity. Click on the “Code” link to the left to see hidden code:\n\n\nCode\n# hidden code revealed!\n\n\n Some code is written using tidyverse syntax. When that’s the case there should be equivalent base R syntax below, indicated as is:\nBase R:\n\n\nCode\n# base R code\n\n\n The site will be updated with additional material as the course proceeds. For comments or questions, please contact:\nlaura.tremblay-boyer at csiro.au or mark.bravington at data61.csiro.au."
  },
  {
    "objectID": "tutorials/coding_tips.html",
    "href": "tutorials/coding_tips.html",
    "title": "CKMR",
    "section": "",
    "text": "The exercises use R functions and object classes from R libraries that were developed specifically for CKMR. As such, some of the syntax might look unfamiliar. We review here key functions or coding concepts used throughout the exercises, but please see the Rcrib.pdf document for a more thorough description."
  },
  {
    "objectID": "tutorials/coding_tips.html#summary-operations-on-offarray-objects",
    "href": "tutorials/coding_tips.html#summary-operations-on-offarray-objects",
    "title": "CKMR",
    "section": "Summary operations on offarray objects",
    "text": "Summary operations on offarray objects\nA common operation (in CKMR and elsewhere) is to apply a function (e.g., the sum) over a specific dimension of an array. In base R the main function to do this is apply, e.g.,\napply(myoa, 1, sum)\nwould sum the values in myoa by rows. To do this with offarray objects you need to convert them to arrays first, e.g.:\n\napply(as.array(oasmp), 1, sum)\n\n2012 2013 2014 2015 \n 1.5  1.1  2.0  1.6 \n\n\nIf the aggregation function is a sum (often the case with CKMR), another option is to use the sumover function which was designed specifically for offarrays.\n\nsumover(oasmp, 1)\n\nB\n[2005] [2006] [2007] [2008] \n   0.8    1.2    2.1    2.1 \n\nsumover(oasmp, 'B')\n\nY\n[2012] [2013] [2014] [2015] \n   1.5    1.1    2.0    1.6 \n\nsumover(oasmp, 'Y')\n\nB\n[2005] [2006] [2007] [2008] \n   0.8    1.2    2.1    2.1 \n\n\nFinally, the option SLICE = is useful to select a single level across other dimensions (and drop the selected dimension).\nWithout SLICE =, we retain the dimensions of the original offarray:\n\noasmp[2012, 2005:2007]\n\n         B\nY         [,2005] [,2006] [,2007]\n  [2012,]     0.4     0.5       0\n\ndim(oasmp[2012, 2005:2007])\n\nY B \n1 3 \n\n\nWith SLICE =, the selected dimension gets dropped from the returned offarray:\n\noasmp[SLICE=2012, 2005:2007]\n\nB\n[2005] [2006] [2007] \n   0.4    0.5    0.0 \n\ndim(oasmp[SLICE=2012, 2005:2007])\n\nB \n3"
  },
  {
    "objectID": "tutorials/coding_tips.html#turning-off-the-byte-compiler",
    "href": "tutorials/coding_tips.html#turning-off-the-byte-compiler",
    "title": "CKMR",
    "section": "Turning-off the byte compiler",
    "text": "Turning-off the byte compiler\nIf you see this error message…\nError in eval(mc, eee) : object '*tmp*' not found\n… you have most likely not turned off the byte compiler. source(\"turn_off_bc.r\") and try again."
  },
  {
    "objectID": "tutorials/coding_tips.html#atease",
    "href": "tutorials/coding_tips.html#atease",
    "title": "CKMR",
    "section": "atease",
    "text": "atease\nIf you see this error message…\nError in extract.named(sampo@public) : trying to get slot \"public\" from an object of a basic class (\"list\") with no slots\nThe atease library was probably not loaded, or was loaded after the exercise functions were defined. Load it, then re-source ckmr_funs.r."
  },
  {
    "objectID": "tutorials/fit_delfi_A_vignette.html",
    "href": "tutorials/fit_delfi_A_vignette.html",
    "title": "Delfinus mendax in the Acme Archipelago",
    "section": "",
    "text": "Code\nlibrary(dplyr) # for the tutorial\n\n## CKMR libraries\nlibrary(mvbutils) # various low-level utilities, eg cq()\nlibrary(offarray) # arrays/vectors don't have to start at 1 any more! Freedom!\nlibrary(debug) # so we can watch the fun\nlibrary(atease)\n\n## for plotting:\nlibrary(ggplot2)\nlibrary(cowplot); theme_set(theme_cowplot(font_size=10))\nlibrary(colorspace)\nlibrary(patchwork)\nlibrary(tidyr)\n\nsource('../ckmr_funs.r') # tutorial functions\nsource('../plonk/turn_off_bc.r') # turn-off the byte-compiler (cf. offarray)\nagemat <- 5 # age at maturity for this species (also in samp_delfi_A@public$Amat)"
  },
  {
    "objectID": "tutorials/fit_delfi_A_vignette.html#diagnostics",
    "href": "tutorials/fit_delfi_A_vignette.html#diagnostics",
    "title": "Delfinus mendax in the Acme Archipelago",
    "section": "Diagnostics",
    "text": "Diagnostics\nDiagnostics for CKMR can be tricky as there is often a very small amount of observed POPs.\nThis example actually contains a huge amount of POPs compared to what we would usually observe, so we can compare observed vs. expected POPs for each sampling year and juvenile birth year.\nThe expected POPs are:\n\nround(sumover(with(env, n_comp_MOP_BYA * Pr_MOP_BYA), c('Bju', 'Aad')), 1)\n\nYad\n[2015] [2016] [2017] [2018] [2019] [2020] \n 136.8  138.1  121.8   85.3   46.6   31.4 \n\n\nand the observed POPs are:\n\nsumover(env$n_MOP_BYA, c('Bju', 'Aad'))\n\nYad\n[2015] [2016] [2017] [2018] [2019] [2020] \n   157    128    114     90     36     35 \n\n\nIf we plot them we can see that prediction appears unbiased with no trend over time.\n\n\nCode\ndiagdf <- data.frame(sumover(with(env, n_comp_MOP_BYA * Pr_MOP_BYA),\n                             c('Bju', 'Aad')),\n                     sumover(env$n_MOP_BYA, c('Bju', 'Aad'))) %>%\n    dplyr::select(Yad, Expected=response, Observed=response.1) %>%\n    gather(Type, Number, Expected:Observed)\n\nggplot(diagdf, aes(Yad, Number, fill=Type)) +\n    geom_bar(stat='identity', position=position_dodge()) +\n    scale_fill_manual(values=c('honeydew3', 'cadetblue3')) +\n    xlab('\\nYear of sampling') + ylab('Count\\n') +\n    theme(legend.position=c(0.8, 0.9))\n\n\n\n\n\nBase R:\n\n\nCode\ntmp <- data.frame(sumover(with(env, n_comp_MOP_BYA * Pr_MOP_BYA),\n                             c('Bju', 'Aad')),\n                     sumover(env$n_MOP_BYA, c('Bju', 'Aad')))\ntmp <- tmp[, c('Yad', 'response', 'response.1')]\n\ndiagdf <- rbind(data.frame(Yad=tmp$Yad,\n                           Number=tmp$response,\n                           Type='Expected'),\n                data.frame(Yad=tmp$Yad,\n                           Number=tmp$response.1,\n                           Type='Observed'))\n\n\n(NB: If we wanted to do this properly we could do a \\(\\chi^2\\)-test.\nFor a normal dataset with less POPs, we would aggregate time-periods instead of inspecting individual years (e.g. first half vs. second half time-series)."
  },
  {
    "objectID": "tutorials/fit_notog21_vignette.html",
    "href": "tutorials/fit_notog21_vignette.html",
    "title": "Notogorgius poutii",
    "section": "",
    "text": "Code\nlibrary(tidyverse) # for the tutorial\nlibrary(data.table)\n\n## CKMR libraries\nlibrary(mvbutils) # various low-level utilities, eg cq()\nlibrary(offarray) # arrays/vectors don't have to start at 1 any more! Freedom!\nlibrary(debug) # so we can watch the fun\nlibrary(atease)\n\n## for plotting:\nlibrary(ggplot2)\nlibrary(cowplot); theme_set(theme_cowplot(font_size=10))\nlibrary(colorspace)\nlibrary(patchwork)\n\nsource('../ckmr_funs.r') # tutorial functions\nsource('../plonk/turn_off_bc.r') # turn-off the byte-compiler (required for offarray to work)\n\nload( '../samp_notog1.rda') # object samp_notog1\nsamp_notog1 <- subset_samples( samp_notog1, Sex=='F') # keeping females only for the exercise\nagemat <- samp_notog1@public$Amat # age at maturity for this species\nIn this CKMR exercise we combine two types of close-kin marks (parent-offsprings and half-siblings) in order to scale population size for a species where fecundity changes with age (i.e. fish-like).\nAs this is a commercially-exploited species, the population model will also account for annual catch data."
  },
  {
    "objectID": "tutorials/fit_notog21_vignette.html#half-sibling-pairs",
    "href": "tutorials/fit_notog21_vignette.html#half-sibling-pairs",
    "title": "Notogorgius poutii",
    "section": "Half-sibling pairs",
    "text": "Half-sibling pairs\nSo far we have considered direct marks only, whereby a juvenile “marks” its parent upon being born and for the parent mark to be recaptured we have to sample both the juvenile and its marked parent (i.e., POPs). Let’s now move on to the `indirect’ marks, the half-sibling pairs (HSPs). Here, the parent mark is recaptured when we have sampled two (or more) of its offspring over different cohorts. In the process, we found out a few things about the parent from the characteristics of its offspring (even though we’ve never actually seen the parent!). First, the parent was mature when the oldest of the sibling was born and second, the parent was still alive when the youngest of the sibling was born. For fish-like species, we also know that the parent contributed more to the total reproductive output the year that the youngest of the sibling was born (since it grew in size and thus, increased its fecundity).\nLet’s look at the number of possible combinations between potential half-sibling pairs. First, note that we’re not accounting for adults in HSPs comparison to avoid including grand-parents. So we’re only considering samples that are possibly juveniles (i.e. 7 years old or younger).\nFor half-siblings, we are only interested in the year they were born (i.e. the cohort they belong to). The dataset has a similar format to that for POPs, that is two columns that index the record in samp_notog1$Samps. Of note the pairs are ordered (by convention) to list the youngest of the sibling first, the oldest second. Comparisons should only be made in one direction (to avoid double-counting) so we pick oldest to youngest and retain it (including in likelihood calculations).\n\nhead(samp_notog1$MHSPs)\n\n     keeps1 keeps2\n[1,]     51    263\n[2,]    130    530\n[3,]    130    531\n[4,]    136    241\n[5,]    211    346\n[6,]    279    955\n\n\nWe can look at the detected (M)HSPs by combination of birth years and compare that to the number of possible pairwise combinations between different birth years (see env$n_comp_MHSP).\n\n\nCode\nbbdf <- with(samp_notog1, data.frame(B1=Samps$B[MHSPs[,1]],\n                                     B2=Samps$B[MHSPs[,2]]))\nbbdfag <- bbdf %>% group_by(B1, B2) %>% tally # count by combinations of birth year\n\nhxl <- range(filter(samp_notog1$Samps, poss_off)$B) + c(-0.5, 0.5)\n\nhc1 <- ggplot(bbdfag, aes(B1, B2, fill=n)) + geom_tile(show.legend=FALSE) +\n    geom_text(aes(label=n), size=2.5) +\n    scale_fill_gradientn(colours=rev(sequential_hcl(40, 'Emrld'))) +\n    geom_hline(yintercept=seq(hxl[1], hxl[2]), colour='grey', size=0.25) +\n    geom_vline(xintercept=seq(hxl[1], hxl[2]), colour='grey', size=0.25) +    \n    annotate('text', x=-Inf, y=Inf, label=paste('n =', nrow(bbdf)), vjust=1.2, hjust=-0.5) +\n    xlab('') +\n    ylab('Birth year of older sibling\\n') + xlim(hxl) + ylim(hxl) +\n\n    ggtitle('Detected HSPs')\n\nhspdf <- samp_notog1$Samps %>% filter(poss_off) %>%\n    group_by(B) %>% tally\n## create df with all possible pairwise combinations of birthyears,\n## filter to only keep combinations where B2 > B1 (note '>'---no same cohort comparisons)\nhspcomp <- expand(hspdf %>% group_by(B, n),\n                  rename(hspdf, B2=B, n2=n) %>% group_by(B2, n2)) %>% filter(B2 > B)\n\nhspcomp$Num <- with(hspcomp, n * n2) # number of pairwise comparisons\n\nhc2 <- ggplot(hspcomp, aes(B, B2, fill=Num)) + \n geom_tile(show.legend=FALSE, colour='grey') +\n    geom_text(aes(label=n), size=2.5) +\n    scale_fill_gradientn(colours=rev(sequential_hcl(40, 'Emrld'))) +\n    xlab('\\nBirth year of younger sibling') +\n    ylab('') + xlim(hxl) + ylim(hxl) +\n    geom_hline(yintercept=seq(hxl[1], hxl[2]), colour='grey', size=0.25) +\n    geom_vline(xintercept=seq(hxl[1], hxl[2]), colour='grey', size=0.25) +\n    ggtitle('# of valid comparisons')\n\nhc1 + hc2 + theme(axis.title.x=element_text(hjust=-0.85)) + plot_layout(nrow=1)\n\n\n\n\n\nIt’s also useful to look at the age difference between the detected half-siblings, as that tells us something about adult survival (and will indeed inform the population model with regards to \\(M\\)):\n\n\nCode\nbbdf$diff <- with(bbdf, B2 - B1)\n\nggplot(bbdf, aes(diff)) + geom_histogram(colour='white') +\n    xlab('\\nAge difference') +\n    ylab('Count\\n')\n\n\n\n\n\nCode\n# Exercise: compare that to the possible age difference given all possible pairwise comparisons\n# hspcomp$diff <- with(hspcomp, B2 - B1)\n# table(with(hspcomp, rep(diff, Num)))\n\n\nSo, most HSPs we detected are separated by one to three years, with a few that go up to 6 years. We’re also learning about parent age, e.g. the parent for the HSPs separated by 6 years was at least 11 years old when they produced the youngest offspring (given age-at-maturity)."
  },
  {
    "objectID": "tutorials/fit_notog21_vignette.html#the-likelihood-for-parent-offspring-pairs",
    "href": "tutorials/fit_notog21_vignette.html#the-likelihood-for-parent-offspring-pairs",
    "title": "Notogorgius poutii",
    "section": "The likelihood for parent-offspring pairs",
    "text": "The likelihood for parent-offspring pairs\nFor POPs, we first need to generate an estimate of fecundity-at-age given wtfecpar:\n\\[ F_a = W_a ^ \\alpha \\]\n(\\(F_a\\) is fecata, \\(W_a\\) is weight and \\(\\alpha\\) is wtfecpar).\nThen, we can get the Total Reproductive Output (TRO) for each year as the sum-product of the abundance-by-age for that year and the fecundity by age:\n\n  TRO_B <- offarray(\n      N_ya[,ADAGES] %**% fecata[ ADAGES], # multiplies then sums across rows\n      first=min_Bju,\n      last=max_Bju)\n\n(We index this by juvenile birth year as we need TRO_B by birth year in the likelihood).\nWe then loop through each combination of juvenile birth year, adult sampling year and adult age to compute the probability that an adult of age \\(A\\) sampled in year \\(Y\\) is the parent of a juvenile born in year \\(B\\). That probability is the ratio of the fecundity of the adult in year in year \\(B\\) (i.e. the fecundity of an adult of age \\(A\\) - (\\(Y - B\\))) to the total reproductive output in year \\(B\\), TRO_B[Bju]. The probability is also scaled by whether the adult would have been mature and still alive in year \\(B\\):\n\nPr_POP_BYA <- autoloop( Bju=Bju_range, Yad=Yad_range, Aad=ADAGES, {\n      Bad <- Yad - Aad\n      ( Bju <= Yad ) *          # was ad still alive at B[ju] ?\n      ( Bju >= Amat + Bad ) *   # was ad mature at B[ju] ?\n      ( fec_fn( Aad - (Yad-Bju)) / TRO_B[ Bju]) # ERRO if above\n    })\n\n… and that’s it for the POP component of the likelihood. We can then compute the expected number of POPs as the product of this probability and the number of possible comparisons for each birth year, sampling year and adult age strata (see below)."
  },
  {
    "objectID": "tutorials/fit_notog21_vignette.html#the-likelihood-for-half-sibling-pairs",
    "href": "tutorials/fit_notog21_vignette.html#the-likelihood-for-half-sibling-pairs",
    "title": "Notogorgius poutii",
    "section": "The likelihood for half-sibling pairs",
    "text": "The likelihood for half-sibling pairs\nComputing the probability of observing a half-sibling pair is a bit more complicated, so it’s been broken down into a few steps.\nStep 1: Cumulative survival—what is the probability that an adult of age A who was the parent of a sibling born in year B1 survived to year B2 to become the parent of the second sibling.\nThat number is simply the ratio of the abundance of adults of age A in year B1 to the abundance of adults of age A + (B2 - B1) in year B2, since the adults will be B2 - B1 years older:\n\n\nCode\npsurv_ayy <- autoloop( a1=ADAGES, y1=Bju_range, y2=Bju_range, {\n    \n      dy <- y2-y1 # Age difference between cohorts\n      a2 <- a1 + abs(dy) # Adult's age when second cohort was born:\n      a2_clip <- pmin(a2, AMAX) # making sure we don't allow Adults > AMAX\n      # (in case adults would have add to be older than AMAX)\n\n      ans <- (dy >= 0) *      # forwards only (i.e. y2 > y1 to avoid double-counting)\n          (a2 <= AMAX) *      # plus-group dies entirely\n          (N_ya[ y2, a2_clip] / N_ya[ y1, a1]) # the probability of survival\n          \n    return(ans)\n    })\n\n\nSince we don’t know the age of the parent (we haven’t sampled it—it’s an indirect mark), we need to compute the probability across all possible parent ages (i.e. 5 to 12) for a given sibling pair.\nStep 2: Get the contribution to TRO of the parent of unknown age in year B1 and in year B2.\nFor convenience, we start by computing the expected contribution to TRO of each adult cohort of age a for each juvenile birth year y (which is equivalent to their conditional age):\n\nPr_Mum1age_B1 <- autoloop(M1a=ADAGES, B1=Bju_range,\n                          N_ya[ B1, M1a] * fecata[ M1a] / TRO_B[ B1])\n\nStep 3:\nWe combine all the previously computed quantities to estimate the joint probability that an adult of a given age A was the parent of an offspring born in year B1 and an offspring born in year B2. For this we account for the parent’s contribution to TRO in B1, the probability of surviving to B2, and the parent’s contribution to TRO in B2, i.e. the product of: - the proportion of adults of age A surviving from B1 to B2 - the contribution of the parent of age A + B2 - B1 to TRO in year B2 - the abundance of parents of age A in B1 scaled by their contribution to TRO in that year (computed in Step 2):\n\nPr_OHSP_B1B2 <- autoloop(B1=Bju_range, B2=Bju_range, SUMOVER=list( M1a=ADAGES), {\n        \n    Pr_OHSP <- (B1 < B2) *                # Youngest sibling first\n        # Given on adult (mum)'s age at B1\n        Pr_Mum1age_B1[ M1a, B1] * # Prop Mum1 was this age?\n        # Probability that adult of age A survived from B1 to B2 *\n        psurv_ayy[ M1a, B1, B2] *         # did Mum1 survive?\n        # Contribution to TRO in B2 of adults of age PARAGE in B2\n        fec_fn( M1a+B2-B1) / TRO_B[ B2]\n\n    # SUMOVER() resulting probability across all possible adult ages (`ADAGES`)\n    return( Pr_OHSP) \n    \n    })\n\nNote the SUMOVER argument to autoloop. This sums over the probability that two HSPs are related across all possible parent ages.\nSo, Pr_OHSP_B1B2 is the probability of a half-sibling pairs for all combinations of B1 and B2 over all possible parent ages at B1.\nNow, we just need to adjust these to account for the proportion of false negative detection for half-siblings, Pr_FNeg_HSP (in this example it’s set to 0 but typically could be 15%).\n\n# allow for known loss-rate due to kinference:\nPr_HSP_B1B2 <- Pr_OHSP * (1-Pr_FNeg_HSP) \n\nSince we don’t know whether HSPs are ordered or not, we add the probabilities of HSPs for both possible directions:\n\n  Pr_HSP_B1B2 <- autoloop( b1=Bju_range, b2=Bju_range,\n    Pr_OHSP_B1B2[ b1, b2] + Pr_OHSP_B1B2[ b2, b1]\n    )\n\n(Double-counting and within-cohort is avoided during data preparation, via n_comp_HSP_B1B2).\nAnd now, we can compile the joint likelihoods for the expected probability of POPs and HSPs given our observations:\n\n lglk <- sum( dpois( n_POP_BYA, lambda=n_comp_POP_BYA*Pr_POP_BYA, log=TRUE)) +\n     sum( dpois( n_HSP_B1B2, lambda=n_comp_HSP_B1B2*Pr_HSP_B1B2, log=TRUE))"
  }
]